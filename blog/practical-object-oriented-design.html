<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Software engineer specializing in full stack web application" />
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/favicon/site.webmanifest">
    <title>Practical Object Oriented Design by Sandi Metz | Nick Arora</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Oswald:wght@200;300;400&&family=JetBrains+Mono:wght@200;300&family=Source+Sans+3:ital,wght@0,200..900;1,200..900&display=swap">
      <link rel="stylesheet" href="/assets/styles/base.css">
    </head>
    <body>
      <header class="primary-header">
        <section class="container">
          <a class="site-id" href="/">Nick Arora</a>
          <nav>
            <label id="theme-toggle">
              <input type="checkbox" />
              <div class="icons">
                <svg class="sun" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path></svg>
                <svg class="moon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
              </div>
            </label>
            <script>
              const dark = "dark"
              const light = "light"
              const themeKey = "theme"

              const toggle = document.getElementById("theme-toggle")
              const checkbox = toggle.querySelector("input")

              function loadTheme() {
                let theme = localStorage.getItem(themeKey) ?? 'light'

                checkbox.checked = theme === dark

                const body = document.body
                body.setAttribute("class", theme)
              }

              checkbox.addEventListener("change", function() {
                const body = document.body
                const reloadTheme = () => setTimeout(() => loadTheme(), 200);

                if (this.checked) {
                  localStorage.setItem(themeKey, dark)
                  reloadTheme()
                } else {
                  localStorage.setItem(themeKey, light)
                  reloadTheme()
                }
              })

              document.addEventListener("DOMContentLoaded", () => {
                loadTheme()
              })
            </script>
          </nav>
        </div>
      </header>
      <main class="primary-content">
        <article class="post container flow">
          <header>
            <h1>Practical Object Oriented Design by Sandi Metz</h1>
            <div class="post-metadata">
              <time datetime="2025-01-16 00:00:00 +0000">January 16, 2025</time>
              <span>
                6 min read
              </span>
            </div>
          </header>
          <picture>
            <source srcset="/assets/images/books/poodr/poodr.avif" type="image/avif" />
            <source srcset="/assets/images/books/poodr/poodr.webp" type="image/webp" />
            <img src="/assets/images/books/poodr/poodr.png" alt="Practical Object Oriented Design" />
          </picture>
          <p>After spending enough time in the software industry, developers come to embrace a single, enduring truth: most applications are a complete mess. It doesn’t always start that way. Many successful businesses are built on the backs of perfectly acceptable code.</p>
          <p>However, as time ticks on, that software endures a constant barrage of new requirements, feature requests, and bug fixes. These changes are often implemented under time pressure. Developers add hack after hack, and the software becomes harder and harder to change. The code calcifies - it’s rigid, brittle, immobile.</p>
          <blockquote>
            <p>The problem with poorly designed small applications is that if they are successful, they grow up to be poorly designed big applications.</p>
          </blockquote>
          <h2 id="the-problem">The Problem</h2>
          <p>Developers absolutely hate working on applications like this. But their distaste is not the real problem. The <em>real</em> problem is that the time and cost necessary to change the application have considerably increased. When a business has a hard time responding to changing market conditions, it can fail outright.</p>
          <p>This paints a dire picture. Thankfully, Sandi Metz’s book, <em>Practical Object Oriented Design</em>, demonstrates how this bleak future can be avoided. The trick is learning to <em>design</em> code so it remains <em>easy to change</em>.</p>
          <blockquote>
            <p>The purpose of design is to allow you to do design later, and it’s primary goal is to reduce the cost of change.</p>
          </blockquote>
          <h2 id="an-object-oriented-approach">An Object-Oriented Approach</h2>
          <p>When developers first learn to write code, they start by writing <em>procedurally</em>. It comes naturally. The developer writes a list of steps. The computer executes them in sequential order. For simple applications, this can often be the best solution.</p>
          <p>However, as the complexity of the application increases, the problems with procedural code start to surface. What was once a simple list of steps has transformed into a complicated, condition-laden, duplicative knot that is hard to understand and almost impossible to change.</p>
          <p>An object-oriented (“OO”) approach offers a countermeasure to this problem. With OO, the code is organized into small, interchangeable units (objects) that collaborate by sending messages to one another. This offers several benefits:</p>
          <ul>
            <li>
              <p><strong>Code can be reused.</strong> Rather than rewriting a procedure, just send a message to an existing object.</p>
            </li>
            <li>
              <p><strong>Easier comprehension.</strong> Developers can focus on the object they’re changing and ignore the details of other objects.</p>
            </li>
            <li>
              <p><strong>Substitutability.</strong> If a new object responds to the same messages, it can stand in for an old one with minimal fuss.</p>
            </li>
          </ul>
          <p>However, it is important to note that OO is not a silver bullet. When used correctly, complex applications become easier to understand and change. But in the wrong hands, OO can be just as convoluted, calcified, and frustrating to change as a procedural code itself. This is why it is so important to study object-oriented design.</p>
          <h2 id="object-oriented-design">Object Oriented Design</h2>
          <p>Good design ensures code is arranged so that it is changeable in the face of unpredictable requirements. Designing for changeability is all about carefully managing dependencies.</p>
          <p>A dependency is created any time one object collaborates with another object. They are a necessity as soon as your application starts doing anything relatively complex. The problem with dependencies is that when they change, things that depend on them may <em>also have to change</em>. In the worst case, even the smallest change can cause a cascade of failures through the codebase.</p>
          <p>To tackle this, Sandi Metz prescribes several battle-tested strategies:</p>
          <ul>
            <li><strong>Create high cohesion objects.</strong> An object is highly cohesive when everything inside it is related to its central purpose. Designing a class in this way ensures it is easy to reuse and less likely to be entangled with other code.</li>
          </ul>
          <blockquote>
            <p>A class should do the smallest possible useful thing; that is, it should have a single responsibility.</p>
          </blockquote>
          <ul>
            <li><strong>Design flexible interfaces.</strong> The messages between objects matter more than the objects themselves. Tell an object “what” you want done, not “how” to do it. This frees you to alter internal implementations without affecting everything else.</li>
          </ul>
          <blockquote>
            <p>Design experts notice domain objects without concentrating on them; they focus not on these objects but on the messages that pass between them</p>
          </blockquote>
          <ul>
            <li><strong>Carefully choose dependency direction.</strong> Some objects change more often than others. By making sure objects depend on those less likely to change, you can minimize disruption.</li>
          </ul>
          <blockquote>
            <p>The choices you make about the direction of dependencies have far reaching consequences that manifest themselves for the life of your application. …if you get it wrong then the dependencies will gradually take over and the application will become harder and harder to change</p>
          </blockquote>
          <ul>
            <li><strong>Change behavior by leveraging dependency injection.</strong> Despite the lofty name, dependency injection is a relatively simple concept. Instead of creating dependencies within your object, push them in from the outside. This means your object no longer depends on some <em>specific</em> class or implementation. Any object that implements the required interface can be pushed in. This makes it straightforward to substitute alternative implementations.</li>
          </ul>
          <blockquote>
            <p>You don’t send messages because you have objects, you have objects because you send messages.</p>
          </blockquote>
          <ul>
            <li><strong>Prefer composition over inheritance.</strong> With inheritance, code is shared through method delegation to a parent class (or mix-in). Though it can sometimes be useful, it comes with significant risk. Inheritance structures are inherently inflexible. As soon as one of the “children” deviates from the others, the entire implementation must be reevaluated. The safer approach is to share code through composition.</li>
          </ul>
          <blockquote>
            <p>Composition contains far fewer built-in dependencies than inheritance; it is very often the best choice.</p>
          </blockquote>
          <ul>
            <li><strong>Write high value tests.</strong> The most common reasons used to justify writing tests are that they reduce bugs and provide documentation. These reasons, while valid, belie a more critical goal. Well written tests reduce the cost of change. They provide an environment where an object’s design can be evaluated and they enable developers to safely modify an implementation.</li>
          </ul>
          <blockquote>
            <p>Tests are your record of the interface of every abstraction and as such they are the wall at your back. They let you put off design decisions and create abstractions to any useful depth.</p>
          </blockquote>
          <h2 id="conclusion">Conclusion</h2>
          <p>In recent years, OO design has received increasing criticism. Developers argue that it becomes bloated with complex class hierarchies and that alternative approaches (like functional programming) are easier to maintain. Sandi Metz reminds us that, when done thoughtfully, OO design remains a powerful way to keep software understandable, maintainable, and, crucially, easy to change.</p>
          <div class="tags">
            <a href="/tag/books" class="tag">
              books
            </a>
            <a href="/tag/software-design" class="tag">
              software design
            </a>
          </div>
        </article>
      </main>
      <footer class="primary-footer">
        <section class="container">
          © 2025 Nick Arora
        </section>
      </footer>
    </body>
  </html>